/*
 * Jexl
 * Copyright (c) 2015 TechnologyAdvice
 */

var handlers = require('./handlers'),
	omit = {},
	EventEmitter = require('events').EventEmitter,
	pending = Promise.pending || function() {
		var deferred = {};
		deferred.promise = new Promise(function(resolve, reject) {
			deferred.resolve = resolve;
			deferred.reject = reject;
		});
		return deferred;
	};

/**
 * The Evaluator takes a Jexl expression tree as generated by the
 * {@link Parser} and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate many different
 * expressions, and does not have to be reinstantiated for each.
 * @param {{}} grammar A grammar map against which to evaluate the expression
 *      tree
 * @param {{}} [transforms] A map of transform names to transform functions. A
 *      transform function takes two arguments:
 *          - {*} val: A value to be transformed
 *          - {{}} args: A map of argument keys to their evaluated values, as
 *              specified in the expression string
 *      The transform function should return either the transformed value, or
 *      a Promises/A+ Promise object that resolves with the value and rejects
 *      or throws only when an unrecoverable error occurs. Transforms should
 *      generally return undefined when they don't make sense to be used on the
 *      given value type, rather than throw/reject. An error is only
 *      appropriate when the transform would normally return a value, but
 *      cannot due to some other failure.
 * @param {{}} [context] A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier. Any
 *      Promise values will be passed to the expression as their resolved
 *      value.
 * @param {{}|Array<{}|Array>} [relativeContext] A map or array to be accessed
 *      to resolve the value of a relative identifier.
 * @constructor
 */
var Evaluator = function(grammar, transforms, context, relativeContext, deferred) {
	this._grammar = grammar;
	this._transforms = transforms || {};
	this._context = context || {};
	this._relContext = relativeContext || this._context;
	this._deferred = deferred || pending();
};

/**
 * Creates a new Evaluator with identical grammar, transforms, context,
 * relativeContext, and deferred.
 * @returns {Evaluator} a new Evaluator
 */
Evaluator.prototype.clone = function() {
	return new Evaluator(this._grammar, this._transforms, this._context,
		this._relContext, this._deferred);
};

/**
 * Evaluates an expression tree within the configured context.
 * @param {{}} ast An expression tree object
 * @returns {Promise<*>} resolves with the resulting value of the expression.
 */
Evaluator.prototype.eval = function(ast) {
	var self = this;
	return this.evalLazy(ast).then(function(res) {
		if (res instanceof EventEmitter)
			return self._consume(res);
		return res;
	});
};

Evaluator.prototype.evalLazy = function(ast) {
	var self = this;
	return Promise.resolve().then(function() {
		return handlers[ast.type].call(self, ast);
	});
};

/**
 * Simultaneously evaluates each line in an expression, and delivers the
 * response as an array with the resulting values at the same indexes as their
 * originating expressions. Resolves the evaluator's deferred after all lines
 * have started evaluating, indicating that all variables that will be added to
 * the context have been added to the context.
 * @param {Array<string>} arr An array of expression strings to be evaluated
 * @returns {Promise<Array<{}>>} resolves with the result array
 */
Evaluator.prototype.evalLines = function(lines, lazy) {
	var results = this.evalArray(lines, lazy);
	this._deferred.resolve();
	return results;
};

/**
 * Simultaneously evaluates each expression within an array, and delivers the
 * response as an array with the resulting values at the same indexes as their
 * originating expressions.
 * @param {Array<string>} arr An array of expression strings to be evaluated
 * @returns {Promise<Array<{}>>} resolves with the result array
 */
Evaluator.prototype.evalArray = function(arr, lazy) {
	var fn = lazy ? this.evalLazy : this.eval;
	return Promise.all(arr.map(fn, this));
};

/**
 * Simultaneously evaluates each expression within a map, and delivers the
 * response as a map with the same keys, but with the evaluated result for each
 * as their value.
 * @param {{}} map A map of expression names to expression trees to be
 *      evaluated
 * @returns {Promise<{}>} resolves with the result map.
 */
Evaluator.prototype.evalMap = function(map) {
	var keys = Object.keys(map),
		result = {};
	var asts = keys.map(function(key) {
		return this.eval(map[key]);
	}, this);
	return Promise.all(asts).then(function(vals) {
		vals.forEach(function(val, idx) {
			result[keys[idx]] = val;
		});
		return result;
	});
};

Evaluator.prototype._consume = function(eventEmitter) {
	return new Promise(function(resolve, reject) {
		var results = [];
		eventEmitter.on('data', results.push.bind(results));
		eventEmitter.on('error', reject);
		eventEmitter.on('end', resolve.bind(Promise, results));
	});
};

/**
 * Applies a subexpression iteratively to the values of a subject. Within the
 * context of the subexpression the '@' identifier refers to the value, the
 * '#' identifier refers to the numeric index if the subject is an array or the
 * string key otherwise, and the '~' identifier indicates that a result for this
 * element should be omitted. If collect is true all results are returned,
 * otherwise the first truthy result is returned.
 *
 * If the subject is not an object of values, it will be converted to a single-
 * element array.
 * @param {*} subject The value to be collected; usually an array. If this value
 *      is not an array, it will be converted to an array with this value as the
 *      only element.
 * @param {{}} expr The expression tree to run against each subject.
 * @returns {Promise<Array>} resolves with an object of mapping the keys of the
 *      subject to their results in the subexpression.
 * @private
 */
Evaluator.prototype._iter = function(obj, expr, collect) {
	if (!((typeof obj === 'object') && !!obj)) {
		throw new Error("Attempting iterable expression: " + expr
			+ "\nover non-iterable: " + obj);
	}
	var idx = 0, over, asObj, results, iter, start, next, process, end, ret, listener;
	iter = (function(val, key) {
		idx++;
		var context = {'@': val, '#': key, '~': omit};
		Object.keys(this._context).forEach(function(k) {
			if (!(k in context))
				context[k] = this._context[k];
		}, this);
		var evalInst = this.clone();
		evalInst._context = context;
		return evalInst.evalLazy(expr).then(process.bind(this, idx, key), end);
	}).bind(this);
	if (obj instanceof EventEmitter) {
		over = {length: Infinity};
		start = function() {
			var processed = 0;
			listener = function(data) {
				iter(data, idx).then(function() {
					processed++;
				});
			};
			obj.on('data', listener);
			obj.on('error', end);
			obj.on('end', function() {
				over.length = idx;
				if (processed === idx)
					end();
			});
		};
	} else if (Array.isArray(obj)) {
		over = obj;
		next = function() {
			iter(obj[idx], idx);
		};
	} else {
		asObj = true;
		over = Object.keys(obj);
		next = function() {
			var key = over[idx];
			iter(obj[key], key);
		};
	}
	if (collect) {
		results = asObj ? {} : new EventEmitter;
		process = function(nextIdx, key, val) {
			if (val !== omit) {
				if (asObj)
					results[key] = val;
				else
					results.emit('data', val);
			}
			if (nextIdx >= over.length)
				end();
		};
		start = start || over.map.bind(over, next);
	} else {
		process = function(nextIdx, key, val) {
			if (val && val !== omit)
				results = val;
			else if (nextIdx < over.length)
				return next();
			end();
		};
		start = start || next;
	}
	if (results instanceof EventEmitter) {
		end = function(err) {
			if (listener)
				obj.removeListener('data', listener);
			if (err)
				return results.emit('error', err);
			results.emit('end');
		};
		ret = results;
	} else {
		ret = new Promise(function(resolve, reject) {
			end = function(err) {
				if (err)
					return reject(err);
				resolve(results);
			};
		});
	}
	start();
	return ret;
};

/**
 * Applies a filter expression with relative identifier elements to a subject.
 * The intent is for the subject to be an array of subjects that will be
 * individually used as the relative context against the provided expression
 * tree. Only the elements whose expressions result in a truthy value will be
 * included in the resulting array.
 *
 * If the subject is not an array of values, it will be converted to a single-
 * element array before running the filter.
 * @param {*} subject The value to be filtered; usually an array. If this value
 *      is not an array, it will be converted to an array with this value as the
 *      only element.
 * @param {{}} expr The expression tree to run against each subject. If the
 *      tree evaluates to a truthy result, then the value will be included in
 *      the returned array; otherwise, it will be eliminated.
 * @returns {Promise<Array>} resolves with an array of values that passed the
 *      expression filter.
 * @private
 */
Evaluator.prototype._filterRelative = function(subject, expr) {
	var self = this,
		promises = [];
	if (!Array.isArray(subject))
		subject = [subject];
	subject.forEach(function(elem) {
		var evalInst = this.clone();
		evalInst._relContext = elem;
		promises.push(evalInst.eval(expr));
	}, this);
	return Promise.all(promises).then(function(values) {
		var results = [];
		values.forEach(function(value, idx) {
			if (value)
				results.push(subject[idx]);
		});
		return results;
	});
};

/**
 * Applies a static filter expression to a subject value.  If the filter
 * expression evaluates to boolean true, the subject is returned; if false,
 * undefined.
 *
 * For any other resulting value of the expression, this function will attempt
 * to respond with the property at that name or index of the subject.
 * @param {*} subject The value to be filtered.  Usually an Array (for which
 *      the expression would generally resolve to a numeric index) or an
 *      Object (for which the expression would generally resolve to a string
 *      indicating a property name)
 * @param {{}} expr The expression tree to run against the subject
 * @returns {Promise<*>} resolves with the value of the drill-down.
 * @private
 */
Evaluator.prototype._filterStatic = function(subject, expr) {
	return this.eval(expr).then(function(res) {
		if (typeof res === 'boolean')
			return res ? subject : undefined;
		return subject[res];
	});
};

module.exports = Evaluator;
